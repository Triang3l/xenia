// NOTE: This file is compiled and embedded into the exe.
//       Use `xb genspirv` and check in any changes under bin/.

#version 450 core
#extension all : warn
#extension GL_ARB_compute_shader : require
#extension GL_ARB_separate_shader_objects : require
#extension GL_ARB_shader_image_load_store : require
#extension GL_ARB_shading_language_420pack : require

// 2 groups per tile (80x16 threads per group is too much).
layout(local_size_x = 40, local_size_y = 16, local_size_z = 1) in;

layout(push_constant) uniform push_consts_type {
  uint edram_offset_tiles;
  uint edram_pitch_tiles;
  uint buffer_pitch_px;
} push_constants;

layout(set = 0, binding = 0, r32ui) uniform readonly uimage2DArray edram;
layout(set = 0, binding = 1, r32ui) uniform writeonly uimageBuffer buffer_depth;
layout(set = 0, binding = 2, r8ui)
    uniform writeonly uimageBuffer buffer_stencil;

// 20e4 - based on CFloat24 from d3dref9.dll and the 6e4 code from:
// https://github.com/Microsoft/DirectXTex/blob/master/DirectXTex/DirectXTexConvert.cpp
// 6e4 has a different exponent bias allowing [0,512) values, 20e4 allows [0,2).
// We also can't clamp the stored value to 1 as load->store->load must be exact.

uint Float20e4To32(uint bits24) {
  uint mantissa = bits24 & 0xFFFFFu;
  uint exponent = (bits24 >> 20u) & 0xFu;
  if (exponent == 0u) {
    if (mantissa != 0u) {
      // Normalize the value in the resulting float.
      // Exponent = 1;
      // do { Exponent--; Mantissa <<= 1; } while ((Mantissa & 0x100000) == 0);
      uint mantissa_lzcnt = uint(20 - findMSB(mantissa));
      exponent = 1u - mantissa_lzcnt;
      mantissa = (mantissa << mantissa_lzcnt) & 0xFFFFFu;
    } else {
      // Zero - set biased exponent to -112.
      exponent = 0xFFFFFF90u;
    }
  }
  return ((exponent + 112u) << 23u) | (mantissa << 3u);
}

uint Float32To20e4(uint bits32) {
  // Only positive (high bit set means negative for both float and int), and
  // saturate to the maximum representable value (also dropping NaNs).
  bits32 = uint(clamp(int(bits32), 0, 0x3FFFFFFB));
  if (bits32 < 0x38800000u) {
    // The number is too small to be represented as a normalized 20e4.
    // Convert it to a denormalized value.
    bits32 = ((bits32 & 0x7FFFFFu) | 0x800000u) >> (113u - (bits32 >> 23u));
  } else {
    // Rebias the exponent to represent the value as a normalized 20e4.
    bits32 += 0xC8000000u;
  }
  return ((bits32 + 3u + ((bits32 >> 3u) & 1u)) >> 3u) & 0xFFFFFFu;
}

void main() {
  uint tile_index = push_constants.edram_offset_tiles + gl_WorkGroupID.y *
                    push_constants.edram_pitch_tiles + (gl_WorkGroupID.x >> 1);
  uvec3 edram_coord = uvec3(tile_index & 15, tile_index >> 4, 0) *
                      uvec3(80, 16, 0) + gl_LocalInvocationID;
  edram_coord.x += (gl_WorkGroupID.x & 1) * 40;
  uint stencil_depth_guest = imageLoad(edram, ivec3(edram_coord)).r;
  uint depth_guest = stencil_depth_guest >> 8u;
  edram_coord.z = 1;
  uint depth_host = imageLoad(edram, ivec3(edram_coord)).r;
  if (depth_guest != Float32To20e4(depth_host)) {
    // Depth could be overwritten by color, for example - in this case, use the
    // new, but less precise value because it may be used again as color later.
    depth_host = Float20e4To32(depth_guest);
  }
  int pixel_index =
      int(gl_GlobalInvocationID.y * push_constants.buffer_pitch_px +
          gl_GlobalInvocationID.x);
  imageStore(buffer_depth, pixel_index, uvec4(depth_host));
  imageStore(buffer_stencil, pixel_index, uvec4(stencil_depth_guest & 0xFFu));
}
